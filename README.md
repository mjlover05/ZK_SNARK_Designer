# ZK_SNARK_Designer
Generate a proof using inputs A=0 B=1.
Compile the circuit to generate circuit intermediaries.
Call the verifyProof() method on the verifier contract and assert output is true

# Discription
We have made a circuit designed to get a output q from some inputs.
a=0 b=1 will goto andGate and and gives output as 0 which will be x.
b=1 will goto to notGate  and gives result as 0 which will be y.
x and y will goto to orGate and result will be q.
0 or 0 will give 0 that means our circuit is giving result true.

## Quick Start

Compile the Multiplier2() circuit and verify it against a smart contract verifier

```
pragma circom 2.0.0;

/*This circuit template checks that c is the multiplication of a and b.*/  

template Multiplier2 () {  

// signal input
    signal input a;
    signal input b;

    // signals from gates
    signal x;
    signal y;

    // final signal output
    signal output q;

    // component used to create custom circuit
    component andGate = AND();
    component notGate = NOT();
    component orGate = OR();

    // circuit logic
    andGate.a <== a;
    andGate.b <== b;
    notGate.in <== b;
    x <== andGate.out ;
    y <== notGate.out;

    orGate.a <== x;
    orGate.b <== y;
    q <== orGate.out; 
}

template AND() {
    signal input a;
    signal input b;
    signal output out;

    out <== a*b;
}

template NOT() {
    signal input in;
    signal output out;

    out <== 1 + in - 2*in;
}

template OR() {
    signal input a;
    signal input b;
    signal output out;

    out <== a + b - a*b;
}

component main = Multiplier2();
```
# guide by Metacrafter for using these lib and modules

### Install
`npm i`

### Compile
`npx hardhat circom` 
This will generate the **out** file with circuit intermediaries and geneate the **MultiplierVerifier.sol** contract

### Prove and Deploy
`npx hardhat run scripts/deploy.ts`
This script does 4 things  
1. Deploys the MultiplierVerifier.sol contract
2. Generates a proof from circuit intermediaries with `generateProof()`
3. Generates calldata with `generateCallData()`
4. Calls `verifyProof()` on the verifier contract with calldata

With two commands you can compile a ZKP, generate a proof, deploy a verifier, and verify the proof ðŸŽ‰

## Configuration
### Directory Structure
**circuits**
```
â”œâ”€â”€ multiplier
â”‚   â”œâ”€â”€ circuit.circom
â”‚   â”œâ”€â”€ input.json
â”‚   â””â”€â”€ out
â”‚       â”œâ”€â”€ circuit.wasm
â”‚       â”œâ”€â”€ multiplier.r1cs
â”‚       â”œâ”€â”€ multiplier.vkey
â”‚       â””â”€â”€ multiplier.zkey
â”œâ”€â”€ new-circuit
â””â”€â”€ powersOfTau28_hez_final_12.ptau
```
Each new circuit lives in it's own directory. At the top level of each circuit directory lives the circom circuit and input to the circuit.
The **out** directory will be autogenerated and store the compiled outputs, keys, and proofs. The Powers of Tau file comes from the Polygon Hermez ceremony, which saves time by not needing a new ceremony. 


**contracts**
```
contracts
â””â”€â”€ MultiplierVerifier.sol
```
Verifier contracts are autogenerated and prefixed by the circuit name, in this example **Multiplier**

## hardhat.config.ts
```
  circom: {
    // (optional) Base path for input files, defaults to `./circuits/`
    inputBasePath: "./circuits",
    // (required) The final ptau file, relative to inputBasePath, from a Phase 1 ceremony
    ptau: "powersOfTau28_hez_final_12.ptau",
    // (required) Each object in this array refers to a separate circuit
    circuits: JSON.parse(JSON.stringify(circuits))
  },
```
# verify
visit: https://mumbai.polygonscan.com
polygonscan testnet will be opened and we have to search the addresss on which project is deployed.
Then will get the expected output and clicking on transcation shows all details of deployment and verification.

# Author 
Manish Kumar
